package EventStore.Client.Messages;

/*
 * So you want to write an event store client, this is a good place to start. This file 
 * defines all of the message contracts between the client and the server over the TCP
 * protocol.
 *
 * Before going into detail its probably best to talk about higher level things first
 * for building a single node connected client then for a client that handles talking
 * to a cluster of nodes. In both scenarios the protocol is relatively simple and the
 * clustered version (HA) is an extension of the single node client.
 *
 * The protocol for talking to the event store is asynchronous unlike many similar 
 * systems (it is also full duplex). Generally you send a message and eventually get
 * a response or timeout (and retry, more on this later). All operations have associated
 * with them a correlation id. The server will respond to your operation including the 
 * correlation id that you atteched to the request. This allows for very large number 
 * of requests to be done over a single TCP connection but makes writing some tools a
 * little more difficult. The messages that are sent are also protobufs as opposed to 
 * text which can make some client examples more difficult to deal with.
 *
 * The general workflow of sending a message to the event store is:
 * Send (correlationid 3)
 * Send (correlationid 5)
 * Recv (correaltionid 5)
 * Recv (correlationid 3)
 *
 * A client for event store could do this completely synchronously (eg Send 3/wait recv)
 * but you probably don't want to do this. This also is where the standard comes from
 * that event store connections tend to be long lived.
 *
 * Clustered Nodes 
 *
 * Dealing with a cluster is a bit more work than dealing with a single node, the reason
 * for this is that the client needs to be aware of the cluster setup in many circumstances
 * especially when dealing with WANs and things like consistency assurances need to be
 * taken into consideration.
 *
 * Information about the current state of the cluster is handled through another protocol
 * gossip over http. The uri /gossip gives the gossip information. A client probably wants
 * to implement gossip with the nodes to get information about the cluster.
 *
 * Most clients in general want to prefer to be connected to the master node if they can
 * be. This is because the master is assured to be up to date and the master is the node
 * that handles coordination of writes. If you try to write to a node that is not the 
 * current master that node will forward the request to the master node. Consider what 
 * happens when you have a WAN
 *
 * Client->Slave (forwards)->Master (writes)->Slave (replication) acks->Master->Slave->Response
 *
 * thus you pay the latency penalty twice on the link between the master and the slave.
 *
 * On master its:
 * Client->Master (writes)->Slave (replication) acks->Master->Response
 *
 * This can make a very big difference in perceived performance but requires that the client
 * gossip in order to figure out who the master is, There is another case that you may really
 * care about whether you are connected to a master vs a slave and this has to do with 
 * consistency of reads.
 *
 *
 *
 *
 */



enum OperationResult
{
	Success = 0;
	PrepareTimeout = 1;
	CommitTimeout = 2;
	ForwardTimeout = 3;
	WrongExpectedVersion = 4;
	StreamDeleted = 5;
	InvalidTransaction = 6;
	AccessDenied = 7;
}

message NewEvent {
	required bytes event_id = 1;
	required string event_type = 2;
	required int32 data_content_type = 3;
	required int32 metadata_content_type = 4;
	required bytes data = 5;
	optional bytes metadata = 6;
}

message EventRecord {
	required string event_stream_id = 1;
	required int32 event_number = 2;
	required bytes event_id = 3;
	required string event_type = 4;
	required int32 data_content_type = 5;
	required int32 metadata_content_type = 6;
	required bytes data = 7;
	optional bytes metadata = 8;
	optional int64 created = 9;
	optional int64 created_epoch = 10;
}

message ResolvedIndexedEvent {
	required EventRecord event = 1;
	optional EventRecord link = 2;
}

message ResolvedEvent {
	required EventRecord event = 1;
	optional EventRecord link = 2;
	required int64 commit_position = 3;
	required int64 prepare_position = 4;
}

/*
 * Writes some events to a Stream.
 */
message WriteEvents {
	required string event_stream_id = 1;
	required int32 expected_version = 2;
	repeated NewEvent events = 3;
	required bool require_master = 4;
}


/*
 * Response to WriteEvents
 */
message WriteEventsCompleted {
	required OperationResult result = 1;
	optional string message = 2;
	required int32 first_event_number = 3;
	required int32 last_event_number = 4;
	optional int64 prepare_position = 5;
	optional int64 commit_position = 6;
}


/*
 * Deletes a stream
 */
message DeleteStream {
	required string event_stream_id = 1;
	required int32 expected_version = 2;
	required bool require_master = 3;
	optional bool hard_delete = 4;
}


/*
 * Response to deleting a stream
 */
message DeleteStreamCompleted {
	required OperationResult result = 1;
	optional string message = 2;
	optional int64 prepare_position = 3;
	optional int64 commit_position = 4;
}


/*
 * Starts a transaction for doing multiple asynchronous
 * writes to the system.
 */
message TransactionStart {
	required string event_stream_id = 1;
	required int32 expected_version = 2;
	required bool require_master = 3;
}

/*
 * Response to a TrDo aansactionStart
 *
 * Note that the transaction id is not scoped to a connection etc
 * as such it can be used between connections (or even multiple
 * clients if you are feeling a bit insane!
 */
message TransactionStartCompleted {
	required int64 transaction_id = 1;
	required OperationResult result = 2;
	optional string message = 3;
}

/*
 * Do a write inside of a transaction.
 * 
 * Note: Its best if you can use expected version = any. 
 * otherwise you can get an error on commit due to 
 * expected version conflicts (transaction does not lock)
 */
message TransactionWrite {
	required int64 transaction_id = 1;
	repeated NewEvent events = 2;
	required bool require_master = 3;
}

/*
 * Response to a TransactionWrite
 */
message TransactionWriteCompleted {
	required int64 transaction_id = 1;
	required OperationResult result = 2;
	optional string message = 3;
}


/*
 * Commits a previously started transaction by its id
 */
message TransactionCommit {
	required int64 transaction_id = 1;
	required bool require_master = 2;
}


/*
 * Response to a transaction commit.
 */
message TransactionCommitCompleted {
	required int64 transaction_id = 1;
	required OperationResult result = 2;
	optional string message = 3;
	required int32 first_event_number = 4;
	required int32 last_event_number = 5;
	optional int64 prepare_position = 6;
	optional int64 commit_position = 7;
}

message ReadEvent {
	required string event_stream_id = 1;
	required int32 event_number = 2;
	required bool resolve_link_tos = 3;
	required bool require_master = 4;
}

message ReadEventCompleted {

	enum ReadEventResult {
		Success = 0;
		NotFound = 1;
		NoStream = 2;
		StreamDeleted = 3;
		Error = 4;
		AccessDenied = 5;
	}

	required ReadEventResult result = 1;
	required ResolvedIndexedEvent event = 2;

	optional string error = 3;
}

message ReadStreamEvents {
	required string event_stream_id = 1;
	required int32 from_event_number = 2;
	required int32 max_count = 3;
	required bool resolve_link_tos = 4;
	required bool require_master = 5;
}

message ReadStreamEventsCompleted {

	enum ReadStreamResult {
		Success = 0;
		NoStream = 1;
		StreamDeleted = 2;
		NotModified = 3;
		Error = 4;
		AccessDenied = 5;
	}

	repeated ResolvedIndexedEvent events = 1;
	required ReadStreamResult result = 2;
	required int32 next_event_number = 3;
	required int32 last_event_number = 4;
	required bool is_end_of_stream = 5;
	required int64 last_commit_position = 6;

	optional string error = 7;
}

message ReadAllEvents {
	required int64 commit_position = 1;
	required int64 prepare_position = 2;
	required int32 max_count = 3;
	required bool resolve_link_tos = 4;
	required bool require_master = 5;
}

message ReadAllEventsCompleted {

	enum ReadAllResult {
		Success = 0;
		NotModified = 1;
		Error = 2;
		AccessDenied = 3;
	}

	required int64 commit_position = 1;
	required int64 prepare_position = 2;
	repeated ResolvedEvent events = 3;
	required int64 next_commit_position = 4;
	required int64 next_prepare_position = 5;

	optional ReadAllResult result = 6 [default = Success];
	optional string error = 7;
}

message CreatePersistentSubscription {
	required string subscription_group_name = 1;
	required string event_stream_id = 2;
   	required bool resolve_link_tos = 3;
   	required int32 start_from = 4;
   	required int32 message_timeout_milliseconds = 5;
  	required bool record_statistics = 6;
	required int32 live_buffer_size = 7;
	required int32 read_batch_size = 8;
	required int32 buffer_size = 9;
	required int32 max_retry_count = 10;
	required bool prefer_round_robin = 11;
	required int32 checkpoint_after_time = 12;
	required int32 checkpoint_max_count = 13;
	required int32 checkpoint_min_count = 14;
}

message DeletePersistentSubscription {
	required string subscription_group_name = 1;
	required string event_stream_id = 2;
}

message UpdatePersistentSubscription {
	required string subscription_group_name = 1;
	required string event_stream_id = 2;
   	required bool resolve_link_tos = 3;
   	required int32 start_from = 4;
   	required int32 message_timeout_milliseconds = 5;
  	required bool record_statistics = 6;
	required int32 live_buffer_size = 7;
	required int32 read_batch_size = 8;
	required int32 buffer_size = 9;
	required int32 max_retry_count = 10;
	required bool prefer_round_robin = 11;
	required int32 checkpoint_after_time = 12;
	required int32 checkpoint_max_count = 13;
	required int32 checkpoint_min_count = 14;
}

message UpdatePersistentSubscriptionCompleted {
	enum UpdatePersistentSubscriptionResult {
		Success = 0;
		DoesNotExists = 1;
		Fail = 2;
		AccessDenied=3;
	}
	required UpdatePersistentSubscriptionResult result = 1 [default = Success];
	optional string reason = 2;
}

message CreatePersistentSubscriptionCompleted {
	enum CreatePersistentSubscriptionResult {
		Success = 0;
		AlreadyExists = 1;
		Fail = 2;
		AccessDenied=3;
	}
	required CreatePersistentSubscriptionResult result = 1 [default = Success];
	optional string reason = 2;
}

message DeletePersistentSubscriptionCompleted {
	enum DeletePersistentSubscriptionResult {
		Success = 0;
		DoesNotExist = 1;
		Fail = 2;
		AccessDenied = 3;
	}
	required DeletePersistentSubscriptionResult result = 1 [default = Success];
	optional string reason = 2;
}

message ConnectToPersistentSubscription {
	required string subscription_id = 1;
	required string event_stream_id = 2;
	required int32 allowed_in_flight_messages = 3;

}

message PersistentSubscriptionAckEvents {
	required string subscription_id = 1;
	repeated bytes processed_event_ids = 2;
}

message PersistentSubscriptionNakEvents {
	enum NakAction {
		Unknown = 0;
		Park = 1;
		Retry = 2;
		Skip = 3;
		Stop = 4;
	}

	required string subscription_id = 1;
	repeated bytes processed_event_ids = 2;
	optional string message = 3;
	required NakAction action = 4 [default = Unknown];
}

message PersistentSubscriptionConfirmation {
	required int64 last_commit_position = 1;
	required string subscription_id = 2;
	optional int32 last_event_number = 3;
}

message PersistentSubscriptionStreamEventAppeared {
	required ResolvedIndexedEvent event = 1;
}

message SubscribeToStream {
	required string event_stream_id = 1;
	required bool resolve_link_tos = 2;
}

message SubscriptionConfirmation {
	required int64 last_commit_position = 1;
	optional int32 last_event_number = 2;
}

message StreamEventAppeared {
	required ResolvedEvent event = 1;
}

message UnsubscribeFromStream {
}

message SubscriptionDropped {

	enum SubscriptionDropReason {
		Unsubscribed = 0;
		AccessDenied = 1;
		NotFound=2;
		PersistentSubscriptionDeleted=3;
	}
	
	optional SubscriptionDropReason reason = 1 [default = Unsubscribed];
}

message NotHandled {
	
	enum NotHandledReason {
		NotReady = 0;
		TooBusy = 1;
		NotMaster = 2;
	}
	
	required NotHandledReason reason = 1;
	optional bytes additional_info = 2;

	message MasterInfo {
		required string external_tcp_address = 1;
		required int32 external_tcp_port = 2;
		required string external_http_address = 3;
		required int32 external_http_port = 4;
		optional string external_secure_tcp_address = 5;
		optional int32 external_secure_tcp_port = 6;
	}
}

/*
 * Starts a DB scavenge on the database.
 */
message ScavengeDatabase {
}

/*
 * Response for a DB scavenge command
 * success = scavenge started
 * inprogress = already running (note non-idempotent as no id)
 * fail = failed for some reason check error.
 *
 * Note: scavenging can take a long time.
 */
message ScavengeDatabaseCompleted {
	
	enum ScavengeResult {
		Success = 0;
		InProgress = 1;
		Failed = 2;
	}
	
	required ScavengeResult result = 1;
	optional string error = 2;
	required int32 total_time_ms = 3;
	required int64 total_space_saved = 4;
}
